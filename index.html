<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Meadsloch Downs — Axebeak Races</title>
<style>
  :root{
    --bg:#1669b2; /* track blue */
    --panel:#0f4980;
    --ink:#eef3ff;
    --muted:#c9d9ff;
    --accent:#ffd86b;
    --ok:#33d17a; --warn:#f6c744; --bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,
       "Apple Color Emoji","Segoe UI Emoji";background:var(--bg);color:var(--ink)}
  header{display:flex;align-items:center;gap:16px;padding:18px 20px;border-bottom:2px solid rgba(255,255,255,.15)}
  header img{height:64px}
  h1{margin:0;font-size:clamp(22px,4vw,36px);letter-spacing:.5px}
  .wrap{display:grid;grid-template-columns:1fr;gap:16px;padding:16px;max-width:1200px;margin:0 auto}
  .row{display:grid;grid-template-columns:1fr;gap:16px}
  @media (min-width:980px){.row{grid-template-columns: 1.1fr .9fr}}
  .card{background:rgba(0,0,0,.18);border:1px solid rgba(255,255,255,.15);border-radius:16px;padding:14px 16px;backdrop-filter:blur(3px)}
  .card h2{margin:.2rem 0 8px;font-size:22px}
  .small{font-size:13px;color:var(--muted)}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.12)}
  th{text-align:left;color:var(--muted);font-weight:600}
  td.odds{font-variant-numeric: tabular-nums}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:end}
  select,input,button{font:inherit;border-radius:10px;border:1px solid rgba(255,255,255,.15);padding:10px 12px;background:rgba(255,255,255,.08);color:var(--ink)}
  input[type=number]{width:110px}
  button{cursor:pointer;background:linear-gradient(180deg, #ffd86b, #ffb938);color:#1a1600;border:none;font-weight:700}
  button.secondary{background:rgba(255,255,255,.08);color:var(--ink);border:1px solid rgba(255,255,255,.25)}
  button:disabled{opacity:.55;cursor:not-allowed}
  .grid-bets{display:grid;grid-template-columns: repeat(1, minmax(0,1fr));gap:12px}
  @media (min-width:700px){.grid-bets{grid-template-columns: repeat(2, minmax(0,1fr))}}
  @media (min-width:1100px){.grid-bets{grid-template-columns: repeat(3, minmax(0,1fr))}}
  .laneWrap{padding:10px 14px}
  .track{position:relative;height:420px;border-radius:16px;background:linear-gradient(#175a97,#124a80);box-shadow: inset 0 0 0 3px rgba(255,255,255,.15)}
  .lane{position:absolute;left:0;right:0;height:calc(100%/8);border-top:1px dashed rgba(255,255,255,.25)}
  .lane:first-child{border-top:none}
  .ax{position:absolute;height:44px;left:0;transform:translateY(-50%)}
  .finish{position:absolute;right:24px;top:0;bottom:0;width:4px;background: repeating-linear-gradient(180deg,#fff 0 14px, transparent 14px 28px)}
  .leaders{display:flex;gap:10px;align-items:center}
  .pill{padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.15)}
  .center{text-align:center}
  .rsg{font-weight:800; font-size:40px; letter-spacing:1px}
  .hidden{display:none}
  .mono{font-variant-numeric: tabular-nums}
  .payoutWin{color:var(--ok)}.payoutLose{color:var(--bad)}
  .laneBadge{display:inline-block;min-width:1.4em;text-align:center;font-weight:800}
  .lane1{color:#ff3b30;}   /* red */
  .lane2{color:#0a84ff;}   /* blue */
  .lane3{color:#ffd60a;}   /* yellow */
  .lane4{color:#ff2d55;}   /* pink */
  .lane5{color:#ffffff;}   /* white */
  .lane6{color:#30d158;}   /* green */
  .lane7{color:#a2845e;}   /* brown */
  .lane8{color:#bf5af2;}   /* purple */
</style>
</head>
<body>
<header>
  <img src="assets/logo.png" onerror="this.style.display='none'" alt=""/>
  <div>
    <h1>Meadsloch Downs — Axebeak Races</h1>
    <div class="small">Race <span id="raceNo">0000</span> • Player view pops a clean window for audience screens.</div>
  </div>
  <div style="margin-left:auto; display:flex; gap:10px">
    <button id="popBtn" class="secondary" title="Open player view">Pop Player View</button>
  </div>
</header>

<!-- Sounds -->
<audio id="sfxStart" src="assets/racestart.wav"></audio>
<audio id="sfxRacing" src="assets/racing.wav" loop></audio>
<audio id="sfxEnd" src="assets/raceend.wav"></audio>
<audio id="sfxWin" src="assets/win.wav"></audio>
<audio id="sfxLose" src="assets/lose.wav"></audio>

<div class="wrap">
  <div id="screenBet" class="row">
    <section class="card">
      <h2>Next Race — Card</h2>
      <div class="small">Odds are chance to win this race (lower is better). Names come from <code>assets/names.txt</code> if present.</div>
      <table id="tblCard">
        <thead><tr><th>#</th><th>Axebeak</th><th class="mono">Odds</th><th class="mono">Win%</th></tr></thead>
        <tbody></tbody>
      </table>
      <div class="center" style="margin-top:12px">
        <button id="startBtn" style="min-width:220px">Start Race</button>
      </div>
    </section>

    <section class="card">
      <h2>Bets (up to 6)</h2>
      <div class="grid-bets" id="bets"></div>
      <div class="small" style="margin-top:10px">Payouts: Win = full, Place = 1/2, Show = 1/3 (rounded down to the nearest silver).</div>
    </section>
  </div>

  <div id="screenRace" class="card hidden">
    <div class="center rsg" id="rsg">Ready…</div>
    <div class="laneWrap">
      <div class="track" id="track">
        <div class="finish"></div>
      </div>
      <div class="leaders small" style="margin-top:10px">
        Leaders: <span class="pill" id="lead1">—</span><span class="pill" id="lead2">—</span><span class="pill" id="lead3">—</span>
        <span class="pill" id="timer" style="margin-left:auto">0.0s</span>
      </div>
    </div>
    <div id="resultArea" class="hidden">
      <h2>Results</h2>
      <div id="podium" class="small"></div>
      <h3 style="margin-top:10px">Payouts</h3>
      <div id="payouts"></div>
      <div class="center" style="margin-top:14px">
        <button id="newRaceBtn">New Race</button>
      </div>
    </div>
  </div>
</div>

<script>
/***** CONFIG — tweak this knob to set overall spice (0 = calm, 1 = wild) *****/
const CONFIG = {
  spice: 1,            // ← set between 0.0 and 1.0; higher = more swings & upsets
  surpriseWeight: 0.88,  // base chance factor for a surprise winner when mood is 'chaos'
  // Base parameters for moods [straight, spicy, chaos]
  noise1Base:   [4,  9, 14],
  noise2Base:   [2,  4,  6],
  jitterBase:   [6, 14, 22],
  idealBlend:   [0.75, 0.60, 0.50],
  baselineBlend:[0.25, 0.40, 0.50],
  gapScaleTop:  [1.00, 0.60, 0.45], // compress top-3 gaps for tenser battles
};

/***** Audio helpers *****/
function playSfx(id){ const el=document.getElementById(id); if(el){ el.currentTime=0; el.play().catch(()=>{}); } }
function stopSfx(id){ const el=document.getElementById(id); if(el){ el.pause(); el.currentTime=0; } }

/***** Player-view sync *****/
const url = new URL(location.href);
const isPlayerView = url.searchParams.get('view') === 'player';
const chan = new BroadcastChannel('axebeak-downs');
function send(msg){ try{ chan.postMessage(msg); }catch(e){} }
chan.onmessage = (ev)=>{ if(isPlayerView){ handleIncoming(ev.data); } };

/***** State *****/
let card = []; // [{id, lane, name, odds, winProb, winPct}]
let raceNumber = '0000';
let namesPool = [];
let bets = []; // up to 6
let raceOrder = [];
let running = false;
let sim = null;

/***** Utils *****/
const rand = (n)=>Math.floor(Math.random()*n);
const CIRCLED = ['❶','❷','❸','❹','❺','❻','❼','❽'];
const laneBadgeHTML = (id)=>`<span class="laneBadge lane${id}">${CIRCLED[id-1]||id}</span>`;
function gpToText(amountGP){
  const spTotal = Math.floor(amountGP * 10 + 1e-6); // round down to nearest silver
  const gp = Math.floor(spTotal/10);
  const sp = spTotal - gp*10;
  return gp + ' gp' + (sp? (' ' + sp + ' sp'): '');
}

/***** Build betting rows *****/
const betsRoot = document.getElementById('bets');
for(let i=0;i<6;i++){
  const wrap = document.createElement('div');
  wrap.className='card';
  wrap.innerHTML = `
    <div class="small">Bet ${i+1}</div>
    <div class="controls">
      <label>Bet Type<br>
        <select data-key="type">
          <option value="win">Win</option>
          <option value="place">Place</option>
          <option value="show">Show</option>
        </select>
      </label>
      <label>Axebeak<br>
        <select data-key="pick"></select>
      </label>
      <label>Wager (gp)<br>
        <input data-key="amt" type="number" min="1" step="1" placeholder="1"/>
      </label>
      <button class="secondary" data-key="clear">Clear</button>
    </div>
    <div class="small" data-key="summary">—</div>
  `;
  betsRoot.appendChild(wrap);
}

function refreshBetPickers(){
  document.querySelectorAll('select[data-key=\"pick\"]').forEach(sel=>{
    const opts = card.map(r=>`<option value="${r.id}">${CIRCLED[r.id-1]||r.id} ${r.name}</option>`).join('');
    sel.innerHTML = '<option value="">— choose —</option>' + opts;
  });
}

function collectBets(){
  bets = [];
  document.querySelectorAll('#bets > .card').forEach((wrap,idx)=>{
    const type = wrap.querySelector('select[data-key=\"type\"]').value;
    const pick = parseInt(wrap.querySelector('select[data-key=\"pick\"]').value||0,10);
    const amt = parseInt(wrap.querySelector('input[data-key=\"amt\"]').value||0,10);
    const sum = wrap.querySelector('[data-key=\"summary\"]');
    if(pick && amt>=1){
      const r = card.find(x=>x.id===pick);
      sum.textContent = `${type.toUpperCase()} on ${r ? r.name : '—'} — ${amt} gp at 1:${r.odds}`;
      bets.push({idx,type,pick,amt});
    }else{
      sum.textContent = '—';
    }
  });
}

betsRoot.addEventListener('change', collectBets);

betsRoot.addEventListener('click', (e)=>{
  const btn = e.target.closest('button[data-key=\"clear\"]');
  if(!btn) return;
  const wrap = btn.closest('.card');
  wrap.querySelector('select[data-key=\"pick\"]').value = '';
  wrap.querySelector('input[data-key=\"amt\"]').value = '';
  wrap.querySelector('[data-key=\"summary\"]').textContent = '—';
  collectBets();
});

/***** Names *****/
async function loadNames(){
  try{
    const r = await fetch('assets/names.txt', {cache:'no-cache'});
    if(!r.ok) throw new Error('no names');
    const t = await r.text();
    namesPool = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  }catch(e){ namesPool = []; }
}

/***** Card generation *****/
function weightedChoice(items, weights){
  const total = weights.reduce((a,b)=>a+b,0);
  let n = Math.random()*total;
  for(let i=0;i<items.length;i++){
    if(n < weights[i]) return items[i];
    n -= weights[i];
  }
  return items[items.length-1];
}

function newRaceCard(){
  raceNumber = String(1000 + rand(9000));
  document.getElementById('raceNo').textContent = raceNumber;
  // pick 8 names
  const names = [];
  for(let i=1;i<=8;i++){
    let nm = namesPool.length ? namesPool.splice(rand(namesPool.length),1)[0] : `Axebeak ${i}`;
    names.push(nm);
  }
  // odds (longshots rarer)
  const possible = [1,2,3,4,5,6,8,10,12,15,20,25,30,40,54];
  const weights  = [10,9,8,8,7,6,6,5,4,3,2,2,1,1,1];

  card = names.map((name,idx)=>{
    const o = weightedChoice(possible, weights);
    return {id: idx+1, lane: idx+1, name, odds: o, winProb: 1/o};
  });
  const sum = card.reduce((a,b)=>a + 1/b.odds, 0);
  card.forEach(r=> r.winPct = ((1/r.odds)/sum*100));

  const tbody = document.querySelector('#tblCard tbody');
  tbody.innerHTML = card.map(r=>`<tr><td>${laneBadgeHTML(r.id)}</td><td>${r.name}</td><td class=\"odds\">1:${r.odds}</td><td class=\"odds\">${r.winPct.toFixed(1)}%</td></tr>`).join('');

  refreshBetPickers();
  collectBets();
  send({type:'card', raceNumber, card});
}

/***** Finish order *****/
function pickFinishOrder(){
  const pool = [...card];
  const order = [];
  let local = pool.map(r=>({r, w: 1/r.odds}));
  for(let k=0;k<8;k++){
    const total = local.reduce((a,b)=>a+b.w,0);
    let x = Math.random()*total;
    let pick = local[0];
    for(const it of local){ if(x<it.w){ pick = it; break;} x -= it.w; }
    order.push(pick.r);
    local = local.filter(it=>it!==pick);
  }
  return order;
}

/***** Race sim *****/
function startRace(){
  if(running) return; running = true;
  raceOrder = pickFinishOrder();

  const rsg = document.getElementById('rsg');
  rsg.classList.remove('hidden');
  rsg.textContent = 'Ready…';
  document.getElementById('resultArea').classList.add('hidden');
  // Show race screen BEFORE measuring track so heights are non‑zero
  document.getElementById('screenBet').classList.add('hidden');
  document.getElementById('screenRace').classList.remove('hidden');

  // Build lanes/axebeaks now that the element has layout
  const track = document.getElementById('track');
  track.querySelectorAll('.lane').forEach(n=>n.remove());
  track.querySelectorAll('img.ax').forEach(n=>n.remove());
  for(let i=0;i<8;i++){
    const lane = document.createElement('div');
    lane.className = 'lane';
    lane.style.top = `${(i/8)*100}%`; // percentages avoid zero-height issues
    track.appendChild(lane);

    const img = document.createElement('img');
    img.className='ax';
    img.style.top = `${((i+0.5)/8)*100}%`;
    img.style.left = '10px'; // consistent start line for all
    img.src = `assets/axebeak${i+1}.gif`;
    img.alt = `Axebeak ${i+1}`;
    img.dataset.id = String(i+1);
    track.appendChild(img);
  }

  send({type:'screen', screen:'race'});
  send({type:'raceCard', card, raceNumber});

  setTimeout(()=>{ rsg.textContent='Set…';
    setTimeout(()=>{ rsg.textContent='Go!'; beginMotion(); playSfx('sfxStart'); playSfx('sfxRacing');
      setTimeout(()=>rsg.classList.add('hidden'), 500);
    }, 700);
  }, 700);
}

function beginMotion(){
  const track = document.getElementById('track');
  const finishX = track.clientWidth - 60;
  const startX = 10;
  const imgs = [...track.querySelectorAll('img.ax')];
  imgs.forEach((img,i)=>{ img.src = `assets/axebeakrun${i+1}.gif`; });

  // --- Mood: derived from CONFIG.spice so you can tune globally ---
  function rollRaceMood(){
    const s = Math.max(0, Math.min(1, CONFIG.spice));
    const pStraight = Math.pow(1 - s, 1.2) * 0.65 + 0.15;
    const pChaos    = Math.pow(s, 1.2) * 0.30;
    let pSpicy      = 1 - (pStraight + pChaos);
    if(pSpicy < 0) { pSpicy = 0; }
    const r = Math.random();
    let idx = 0; // 0=straight,1=spicy,2=chaos
    if(r < pStraight) idx = 0; else if(r < pStraight + pSpicy) idx = 1; else idx = 2;
    const n1 = CONFIG.noise1Base[idx] * (0.9 + Math.random()*0.25);
    const n2 = CONFIG.noise2Base[idx] * (0.9 + Math.random()*0.25);
    const jit= CONFIG.jitterBase[idx] * (0.9 + Math.random()*0.25);
    const ib = CONFIG.idealBlend[idx];
    const bb = CONFIG.baselineBlend[idx];
    const gTop = CONFIG.gapScaleTop[idx];
    const chaosSurprise = (idx===2 ? CONFIG.surpriseWeight * s : 0);
    const names = ['straight','spicy','chaos'];
    return {name:names[idx], noise1:n1, noise2:n2, jitter:jit, idealBlend:ib, baselineBlend:bb, gapScaleTop:gTop, chaos:chaosSurprise, idx};
  }
  const mood = rollRaceMood();

  // Precompute target FINISH TIME for each runner following the (possibly tweaked) order
  // Invisible checkpoint fractions along the track (position-based, not time)
  const cpFractions = [0.08,0.18,0.28,0.40,0.52,0.66,0.80,0.92];
  const startT = performance.now();
  const state = new Map();
  const orderIds = raceOrder.map(r=>r.id);
  const strength = (odds)=> 1/odds; // lower odds => higher strength

  // Tie-break preference map (defined up-front so rankNow can close over it)
  const __finishPref = new Map();

  // Optionally create a surprise winner (rare, weighted by odds to avoid constant longshots)
  let effectiveOrder = [...orderIds];
  if(mood.name==='chaos' && Math.random() < mood.chaos){
    const pool = orderIds.slice(2,6); // 3rd–6th
    const weights = pool.map(id=> Math.pow(strength(card.find(r=>r.id===id).odds), 0.7));
    const total = weights.reduce((a,b)=>a+b,0);
    let x = Math.random()*total; let idx=0;
    for(let i=0;i<pool.length;i++){ if(x<weights[i]){ idx=i; break;} x-=weights[i]; }
    const surprise = pool[idx];
    effectiveOrder = [surprise, ...orderIds.filter(id=>id!==surprise)];
  }

  // Winner base time 9.0–10.5s; scale with mood a bit
  const winnerBase = (mood.name==='straight'? 9.2 : mood.name==='spicy'? 9.6 : 9.8) + Math.random()*1.1;

  // Assign finish times with compressed top gaps depending on mood
  const finishTimes = new Map();
  finishTimes.set(effectiveOrder[0], winnerBase);
  for(let i=1;i<effectiveOrder.length;i++){
    const prevId = effectiveOrder[i-1];
    const curId  = effectiveOrder[i];
    const prevStr = strength(card.find(r=>r.id===prevId).odds);
    const curStr  = strength(card.find(r=>r.id===curId).odds);
    const closeness = Math.min(1, prevStr/curStr);
    let baseGap = 0.28 + Math.random()*0.28; // 0.28–0.56s
    if(i<3) baseGap *= mood.gapScaleTop; // compress early pack for more duels
    const adjGap = baseGap + (0.35*(1-closeness));
    finishTimes.set(curId, finishTimes.get(prevId) + adjGap);
  }

  // Now that effectiveOrder is known, preload tie-break preferences
  __finishPref.clear();
  effectiveOrder.forEach((id,idx)=> __finishPref.set(id, idx));

  // Per-runner motion state
  imgs.forEach(img=>{
    const id = +img.dataset.id;
    const r = card.find(x=>x.id===id);
    state.set(id, {
      x: parseFloat(img.style.left)||10,
      base: 60 + 120*strength(r.odds),
      phase: Math.random()*Math.PI*2,
      // progress ceiling exponent (lower => faster early progress)
      progExp: ([0.88,0.82,0.78][mood.idx] || 0.85) + (Math.random()*0.12 - 0.06),
      // transient surges / drags
      boost: 0, boostT: 0,
      drag: 0,  dragT: 0,
      // checkpoint control
      cp: 0,
      segMul: 1,
      segMulTarget: 1,
    });
  });

  // Helpers
  const rankNow = ()=>[...imgs].sort((a,b)=>{
    const ax = state.get(+a.dataset.id).x;
    const bx = state.get(+b.dataset.id).x;
    const dx = bx - ax; // descending by x
    if(Math.abs(dx) > 0.6) return dx;
    // tie-ish: prefer earlier finisher from predetermined order
    return (__finishPref.get(+a.dataset.id) ?? 99) - (__finishPref.get(+b.dataset.id) ?? 99);
  }).map(n=>+n.dataset.id);
  function smoothNoise(id, t){
    const st = state.get(id);
    return Math.sin((t*0.7) + st.phase) * mood.noise1
         + Math.sin((t*1.9) + st.phase*0.7) * mood.noise2;
  }

  // Track finish flags per axebeak so we can wait for full field
  const finished = new Set();
  const finishedOrder = []; // lock-in order as birds cross the line

  // Main loop
  function tick(){
    const t = (performance.now() - startT)/1000;

    imgs.forEach(img=>{
      const id = +img.dataset.id;
      const st = state.get(id);
      const r  = card.find(x=>x.id===id);
      const targetT = finishTimes.get(id);

      const remainingT = Math.max(0.05, targetT - t);
      const remainingX = Math.max(0, finishX - st.x);

      const phase = Math.min(1, t / (winnerBase+1.8));

      const ideal = remainingX / remainingT;
      const baseline = st.base;
      const noise = smoothNoise(id, t) * (1 - phase*0.6);

      let speed = ideal*mood.idealBlend + baseline*mood.baselineBlend + noise;

      // random surges and slowdowns for organic back-and-forth
      if(st.boostT<=0 && Math.random()<0.02){ st.boost = 40 + Math.random()*70; st.boostT = 0.5 + Math.random()*1.0; }
      if(st.dragT<=0  && Math.random()<0.012){ st.drag  = 30 + Math.random()*50; st.dragT  = 0.4 + Math.random()*0.9; }
      if(st.boostT>0){ speed += st.boost; st.boost *= 0.92; st.boostT -= 1/60; }
      if(st.dragT>0){  speed -= st.drag;  st.drag  *= 0.90; st.dragT  -= 1/60; }

      const jitterAmp = (mood.jitter * (1-phase)) * (0.6 + 0.4*strength(r.odds));
      speed += (Math.random()-0.5) * jitterAmp;

      // —— Invisible checkpoint controller ——
      // Compare position-progress (pX) with expected time-progress at this runner's schedule.
      const pX = Math.max(0, Math.min(1, (st.x - startX)/(finishX - startX)));
      while(st.cp < cpFractions.length && pX >= cpFractions[st.cp]){
        const expectedP = Math.min(0.995, Math.pow(t/targetT, st.progExp));
        const deficit = expectedP - pX; // + = behind schedule, - = ahead
        let target = st.segMulTarget;
        if(deficit > 0.01){
          // Behind schedule → nudge faster for next segment
          target = 1.08 + Math.min(0.25, deficit*1.6) + (Math.random()-0.5)*0.08;
        }else if(deficit < -0.01){
          // Ahead of schedule → cool off a bit
          target = 0.92 - Math.min(0.20, (-deficit)*1.4) + (Math.random()-0.5)*0.08;
        }else{
          // On schedule → slight randomness so pack breathes
          target = 1.0 + (Math.random()-0.5)*0.04;
        }
        st.segMulTarget = Math.max(0.75, Math.min(1.35, target));
        st.cp++;
      }
      // Smoothly ease toward target to avoid jerks
      st.segMul += (st.segMulTarget - st.segMul) * 0.08;
      speed *= st.segMul;

      speed = Math.max(40, Math.min(speed, 260));

      let nextX = Math.min(finishX, st.x + speed*(1/60));
      // Progress ceiling instead of a hard wall; allows racing early without finishing too soon
      const p = Math.max(0, Math.min(1, (t/targetT)));
      const progCeil = startX + (finishX-startX) * Math.min(0.995, Math.pow(p, state.get(id).progExp));
      if(nextX > progCeil) nextX = Math.max(st.x, progCeil);
      st.x = Math.max(st.x, nextX);
      img.style.left = `${st.x}px`;
      img.style.left = `${st.x}px`;

      // Mark finished when at/after planned time or visually at finish
      if(!finished.has(id) && (t >= targetT || st.x >= finishX-0.5)){
        finished.add(id);
        if(!finishedOrder.includes(id)) finishedOrder.push(id); // lock this place now
      }
    });

    // Build display order with locked finishers first, then current running order
    const runningIds = imgs.map(n=>+n.dataset.id).filter(id=>!finished.has(id));
    const runningOrder = rankNow().filter(id=>runningIds.includes(id));
    const order = [...finishedOrder, ...runningOrder];
    setLeaderText(order);
    send({type:'progress', order});

    // End only when ALL have finished (show full field), with a tiny buffer
    const allFinished = orderIds.every(id=> finished.has(id));
    if(allFinished){
      imgs.forEach(img=>{ const id=+img.dataset.id; if(state.get(id).x>finishX-2){ state.get(id).x=finishX; img.style.left = `${finishX}px`; }});
      // lock leaders to the precomputed final order before rendering results
      setLeaderText(effectiveOrder);
      endRace(order, effectiveOrder);
      return;
    }

    sim = requestAnimationFrame(tick);
  }

  // Start timer display
  const timer = document.getElementById('timer');
  timer.dataset.t0 = String(startT);
  sim = requestAnimationFrame(tick);
}

function setLeaderText(order){
  const nm = id=>card.find(r=>r.id===id)?.name||'';
  document.getElementById('lead1').textContent = `1st: ${nm(order[0]||0)}`;
  document.getElementById('lead2').textContent = `2nd: ${nm(order[1]||0)}`;
  document.getElementById('lead3').textContent = `3rd: ${nm(order[2]||0)}`;
  const timer = document.getElementById('timer');
  if(timer.dataset.t0){
    const dt = (performance.now()-Number(timer.dataset.t0))/1000; timer.textContent = dt.toFixed(1)+'s';
  }
}

function endRace(orderNow, finalOrderIds){
  cancelAnimationFrame(sim);
  running=false;
  stopSfx('sfxRacing');
  playSfx('sfxEnd');

  // Prefer the predetermined (possibly tweaked) final order; fallback to observed order
  const finalIds = Array.isArray(finalOrderIds) && finalOrderIds.length===8
    ? finalOrderIds
    : [...new Set([raceOrder[0].id, ...orderNow, ...raceOrder.map(r=>r.id)])].slice(0,8);

  const podium = finalIds.slice(0,3).map(id=>card.find(r=>r.id===id));

  // Render full standings
  const pod = document.getElementById('podium');
  const full = finalIds.map((id,i)=>`${i+1}. ${card.find(r=>r.id===id).name} (1:${card.find(r=>r.id===id).odds})`).join('<br>');
  pod.innerHTML = `<div><b>Results</b></div>
                   <div style="margin-top:6px">${full}</div>`;

  // Compute payouts from top 3
  const out = document.getElementById('payouts');
  const [w1,w2,w3]=podium.map(p=>p.id);
  let html = '';
  let anyWin=false;
  collectBets();
  bets.forEach((b,i)=>{
    const racer=card.find(r=>r.id===b.pick); if(!racer) return;
    const odds=racer.odds; let won=false; let mult=0;
    if(b.type==='win'&&b.pick===w1){won=true;mult=odds;}
    if(b.type==='place'&&(b.pick===w1||b.pick===w2)){won=true;mult=odds/2;}
    if(b.type==='show'&&(b.pick===w1||b.pick===w2||b.pick===w3)){won=true;mult=odds/3;}
    if(won) anyWin=true;
    const payout = won ? gpToText(b.amt*mult) : '0 gp';
    html += `<div class="pill ${won?'payoutWin':'payoutLose'}">Bet ${i+1}: ${b.type.toUpperCase()} on ${racer.name} — wager ${b.amt} gp → ${payout}</div>`;
  });
  out.innerHTML = html || '<div class="small">No valid bets were placed.</div>';
  document.getElementById('resultArea').classList.remove('hidden');
  if(anyWin) playSfx('sfxWin'); else playSfx('sfxLose');
  send({type:'finish', final: finalIds, podium, bets});
}

/***** Player view handling *****/
function handleIncoming(msg){
  const bet = document.getElementById('screenBet');
  const race = document.getElementById('screenRace');
  if(msg.type==='card'){
    window.__playerCard = msg.card; // stash for later name lookups
    document.getElementById('raceNo').textContent = msg.raceNumber;
    const tbody = document.querySelector('#tblCard tbody');
    tbody.innerHTML = msg.card.map(r=>`<tr><td>${laneBadgeHTML(r.id)}</td><td>${r.name}</td><td class=\"odds\">1:${r.odds}</td><td class=\"odds\">${r.winPct.toFixed(1)}%</td></tr>`).join('');
    // hide DM-only controls (no :has for broad compat)
    const betSection = document.getElementById('bets')?.closest('section');
    if(betSection) betSection.classList.add('hidden');
    document.getElementById('startBtn').disabled = true;
    document.getElementById('popBtn').disabled = true;
    bet.classList.remove('hidden'); race.classList.add('hidden');
  }
  if(msg.type==='screen' && msg.screen==='race'){
    bet.classList.add('hidden'); race.classList.remove('hidden');
  }
  if(msg.type==='progress'){
    setLeaderText(msg.order);
  }
  if(msg.type==='finish'){
    const finalIds = msg.final;
    const pod = document.getElementById('podium');
    const nm = id=> (window.__playerCard||[]).find(r=>r.id===id)?.name || id;
    const full = finalIds.map((id,i)=>`${i+1}. ${nm(id)}`).join('<br>');
    pod.innerHTML = `<div><b>Results</b></div>
                     <div style=\"margin-top:6px\">${full}</div>`;
    document.getElementById('resultArea').classList.remove('hidden');
  }
}

/***** Buttons *****/
const startBtn = document.getElementById('startBtn');
startBtn.addEventListener('click', ()=>{ collectBets(); startRace(); });

document.getElementById('newRaceBtn').addEventListener('click', ()=>{
  document.getElementById('screenRace').classList.add('hidden');
  document.getElementById('screenBet').classList.remove('hidden');
  send({type:'screen', screen:'betting'});
  document.getElementById('lead1').textContent='—';
  document.getElementById('lead2').textContent='—';
  document.getElementById('lead3').textContent='—';
  const timer=document.getElementById('timer'); timer.textContent='0.0s'; delete timer.dataset.t0;
  loadNames().then(()=> newRaceCard());
});

const popBtn = document.getElementById('popBtn');
popBtn.addEventListener('click', ()=>{
  window.open(location.pathname + '?view=player', 'PlayerView', 'width=1200,height=800');
  setTimeout(()=> send({type:'card', raceNumber, card}), 300);
});

/***** Init *****/
(async function init(){
  if(isPlayerView){
    const betSection = document.getElementById('bets')?.closest('section');
    if(betSection) betSection.classList.add('hidden');
    document.getElementById('startBtn').disabled = true;
    document.getElementById('popBtn').disabled = true;
  }
  await loadNames();
  newRaceCard();
})();

/***** Minimal Self-Tests (run automatically once) *****/
(function selfTests(){
  // Test 1: betting slots exist
  console.assert(document.querySelectorAll('#bets > .card').length===6, 'Expected 6 betting slots');
  // Test 2: card rows populate
  console.assert(document.querySelectorAll('#tblCard tbody tr').length===8, 'Expected 8 axebeaks in card');
  // Test 3: start button wired
  console.assert(typeof startRace==='function', 'startRace missing');
  // Test 4: core globals present
  console.assert(typeof CONFIG==='object' && typeof CONFIG.spice==='number', 'CONFIG missing');
  console.assert(typeof handleIncoming==='function', 'handleIncoming missing');
  // Test 5: dropdown labels begin with circled digits and contain no raw numeric prefix artifacts
  (function(){
    refreshBetPickers();
    const anyOpt = document.querySelector('select[data-key="pick"] option[value="1"]');
    console.assert(anyOpt && /[❶-❽]/.test(anyOpt.textContent), 'Expected circled-digit prefix in Axebeak picker');
    console.assert(!/\$\{r\.id\}\./.test(document.body.innerHTML), 'Unexpected leftover template text in document');
  })();
  // Manual race layout test (opt-in to avoid disrupting normal flow)
  // Enable by adding ?debugTests=1 to the URL or setting localStorage.axeDebugTests = '1'
  window.__runTests = () => {
    collectBets();
    newRaceCard();
    const firstCell = document.querySelector('#tblCard tbody tr td');
    console.assert(firstCell && /[❶-❽]/.test(firstCell.textContent), 'Expected circled digit badge in first column');
    startRace();
    setTimeout(()=>{
      const lanes=[...document.querySelectorAll('#track .lane')];
      console.assert(lanes.length===8, 'Expected 8 lanes');
      const ys=[...document.querySelectorAll('#track img.ax')].map(n=>n.style.top);
      console.assert(new Set(ys).size===8, 'Axebeaks should have unique lane positions');
      console.log('Lane tops:', ys);
    }, 1000);
  };
  // If explicitly requested, run __runTests automatically
  try{
    const params = new URLSearchParams(location.search);
    const want = params.get('debugTests')==='1' || localStorage.getItem('axeDebugTests')==='1';
    if(want){ window.__runTests(); }
  }catch(e){}
})();
</script>
</body>
</html>
